// Generated by CoffeeScript 1.3.3
var KeyMap, addNode, addToQueue, addressBook, appearanceCallbacks, appeared, back, captureEvents, changeNode, changeNodeProperty, changesCommitted, copyKeys, descendants, drainQueue, eventMessage, existsNode, fixCSSURL, fixStylesheets, forward, getNodeAddress, getRange, guid, hasUndesirableClickBehavior, inputChange, inputChanged, installEventListeners, isContentEditable, isEditingText, isFileInput, isTextInput, keysEqual, lastLocationId, lastUrl, loadDocument, loadedInitialStuff, markVisited, markWhole, metaWithProperty, modifyAllElements, page, performPath, queue, removeNode, retrieveNodeFromAddress, scrollMemory, selectRange, serializeEvent, serializeRange, setUrl, socket, submitForm, uploadFiles, whenAppears, wrapInSpanRange,
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

socket = io.connect('/page');

scrollMemory = {};

isTextInput = function(node) {
  return node.nodeName === 'INPUT' && /(text|search|tel|email|password)/.test(node.type.toLowerCase());
};

guid = function() {
  var S4;
  S4 = function() {
    return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
  };
  return S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4();
};

loadedInitialStuff = false;

queue = [];

addressBook = {};

addToQueue = function() {
  var args;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  return queue.push(args);
};

changesCommitted = {};

drainQueue = function() {
  var command, rest, _i, _len, _ref, _results;
  _results = [];
  for (_i = 0, _len = queue.length; _i < _len; _i++) {
    _ref = queue[_i], command = _ref[0], rest = 2 <= _ref.length ? __slice.call(_ref, 1) : [];
    console.log(command, rest);
    switch (command) {
      case "node-added":
        _results.push(addNode.apply(null, rest));
        break;
      case "node-remove":
        _results.push(removeNode.apply(null, rest));
        break;
      case "node-attr-modified":
        _results.push(changeNode.apply(null, rest));
        break;
      default:
        _results.push(void 0);
    }
  }
  return _results;
};

socket.on('location-changed', function(url) {
  console.log('location changed', url);
  return loadedInitialStuff = false;
});

socket.on('print', function() {
  return window.print();
});

performPath = function(ctx, path) {
  var args, cmd, _i, _len, _ref, _results;
  ctx.beginPath();
  _results = [];
  for (_i = 0, _len = path.length; _i < _len; _i++) {
    _ref = path[_i], cmd = _ref[0], args = 2 <= _ref.length ? __slice.call(_ref, 1) : [];
    _results.push(ctx[cmd].apply(ctx, args));
  }
  return _results;
};

socket.on('canvas', function() {
  var address, args, canvas, cmd, ctx, fillStyle, h, lineCap, lineJoin, lineWidth, m, maxWidth, miterLimit, path, strokeStyle, text, w, x, y;
  address = arguments[0], cmd = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
  canvas = retrieveNodeFromAddress(address);
  ctx = canvas.getContext('2d');
  switch (cmd) {
    case 'clearRect':
      x = args[0], y = args[1], w = args[2], h = args[3], m = args[4];
      ctx.transform.apply(ctx, m);
      return ctx.clearRect.apply(ctx, args);
    case 'fillRect':
      x = args[0], y = args[1], w = args[2], h = args[3], fillStyle = args[4], m = args[5];
      ctx.transform.apply(ctx, m);
      ctx.fillStyle = fillStyle;
      return ctx.fillRect(x, y, w, h);
    case 'strokeRect':
      x = args[0], y = args[1], w = args[2], h = args[3], strokeStyle = args[4], lineWidth = args[5], lineJoin = args[6], miterLimit = args[7], m = args[8];
      ctx.transform.apply(ctx, m);
      ctx.strokeStyle = strokeStyle;
      ctx.lineWidth = lineWidth;
      ctx.lineJoin = lineJoin;
      ctx.miterLimit = miterLimit;
      return ctx.strokeRect(x, y, w, h);
    case 'fillText':
      text = args[0], x = args[1], y = args[2], maxWidth = args[3], fillStyle = args[4], m = args[5];
      ctx.transform.apply(ctx, m);
      return ctx.fillStyle = fillStyle;
    case 'fill':
      path = args[0], fillStyle = args[1], m = args[2];
      performPath(ctx, path);
      ctx.transform.apply(ctx, m);
      ctx.fillStyle = fillStyle;
      return ctx.fill();
    case 'stroke':
      path = args[0], strokeStyle = args[1], lineWidth = args[2], lineCap = args[3], lineJoin = args[4], miterLimit = args[5], m = args[6];
      performPath(ctx, path);
      ctx.transform.apply(ctx, m);
      ctx.strokeStyle = strokeStyle;
      ctx.lineWidth = lineWidth;
      ctx.lineJoin = lineJoin;
      ctx.miterLimit = miterLimit;
      return ctx.stroke();
  }
});

socket.on('page-served-html', function(id) {
  loadedInitialStuff = false;
  return $.get("/current_page", function(data) {
    var body, head, _ref;
    _ref = data.split('\x00'), head = _ref[0], body = _ref[1];
    document.head.innerHTML = head;
    document.body.innerHTML = body;
    return loadedInitialStuff = true;
  });
});

fixCSSURL = function() {
  var backgroundImage, currentURL, currentURLObj, fixedURL, path, rule, stylesheet, url, urlObj, _i, _len, _ref, _results;
  currentURL = "http://google.com";
  currentURLObj = URI(currentURL);
  _ref = document.styleSheets;
  _results = [];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    stylesheet = _ref[_i];
    _results.push((function() {
      var _j, _len1, _ref1, _results1;
      _ref1 = stylesheet.rules;
      _results1 = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        rule = _ref1[_j];
        if (/url/.test(rule.cssText)) {
          backgroundImage = rule.style.backgroundImage;
          if (/url/.test(backgroundImage)) {
            url = backgroundImage.substring(4, backgroundImage.length - 1);
            urlObj = URI(url);
            if (urlObj.hostname() === "localhost") {
              path = urlObj.path();
              fixedURL = URI(path).absoluteTo(currentURL).toString();
              _results1.push(rule.style.backgroundImage = "url(\"" + fixedURL + "\")");
            } else {
              _results1.push(void 0);
            }
          } else {
            _results1.push(void 0);
          }
        } else {
          _results1.push(void 0);
        }
      }
      return _results1;
    })());
  }
  return _results;
};

fixStylesheets = function() {
  var realHost;
  realHost = 'http://google.com';
  $("style").each(function(index, el) {
    var css, match, matches, uri, url, _, _i, _len, _ref;
    css = el.textContent;
    matches = css.match(/url\([^)]*\)/g);
    if (!matches) {
      return;
    }
    for (_i = 0, _len = matches.length; _i < _len; _i++) {
      match = matches[_i];
      _ref = match.match(/url\(([^)]*)\)/), _ = _ref[0], url = _ref[1];
      uri = URI(url);
      if (uri.host() === '') {
        css = css.replace(url, uri.absoluteTo(realHost).toString());
      }
    }
    return el.textContent = css;
  });
  $("[style]").each(function(index, el) {
    var css, match, matches, uri, url, _, _i, _len, _ref, _ref1;
    css = el.style.cssText;
    matches = css.match(/url\([^)]*\)/g);
    if (!matches) {
      return;
    }
    for (_i = 0, _len = matches.length; _i < _len; _i++) {
      match = matches[_i];
      _ref = match.match(/url\(([^)]*)\)/), _ = _ref[0], url = _ref[1];
      uri = URI(url);
      if ((_ref1 = uri.hostname()) === '' || _ref1 === 'localhost') {
        css = css.replace(url, URI(uri.path()).absoluteTo(realHost).toString());
      }
    }
    return el.style.cssText = css;
  });
  return $("link[rel='stylesheet']").each(function(index, el) {});
};

loadDocument = function(id, sd, options) {
  var currentDocumentID, doc, scrollValues,
    _this = this;
  if (options == null) {
    options = {};
  }
  console.log('loading doc', id);
  currentDocumentID = id;
  console.log('scroll mem', scrollMemory);
  addressBook = {};
  doc = window.document;
  doc.removeChild(doc.documentElement);
  doc.appendChild(deserializeDocument(sd));
  loadedInitialStuff = true;
  drainQueue();
  markVisited(options.visited || documentOptions.visited || []);
  if (scrollValues = scrollMemory[currentDocumentID]) {
    return setTimeout((function() {
      document.body.scrollTop = scrollValues.scrollTop;
      return document.body.scrollLeft = scrollValues.scrollLeft;
    }), 200);
  } else {
    return setTimeout((function() {
      document.body.scrollTop = 0;
      return document.body.scrollLeft = 0;
    }), 200);
  }
};

markVisited = function(locations) {
  return $("a").each(function(index, anchor) {
    var _ref;
    if (_ref = anchor.href, __indexOf.call(locations, _ref) >= 0) {
      return $(anchor).addClass('visited');
    }
  });
};

socket.on('page-served', function(id) {
  loadedInitialStuff = false;
  return $.getJSON("/document", {
    id: tabId
  }, function(_arg) {
    var documentId, serializedDocument;
    serializedDocument = _arg.serializedDocument, documentId = _arg.documentId;
    console.log('received doc', {
      documentId: documentId,
      serializedDocument: serializedDocument
    });
    return loadDocument(documentId, serializedDocument);
  });
});

socket.on('document-changed', function(options) {
  loadedInitialStuff = false;
  return $.getJSON("/document", {
    id: tabId
  }, function(_arg) {
    var documentId, serializedDocument;
    serializedDocument = _arg.serializedDocument, documentId = _arg.documentId;
    console.log('received doc', {
      documentId: documentId,
      serializedDocument: serializedDocument
    });
    return loadDocument(documentId, serializedDocument);
  });
});

page = null;

appearanceCallbacks = {};

modifyAllElements = function(callback) {
  var acceptNode, child, walker, _results;
  acceptNode = function(node) {
    return NodeFilter.FILTER_ACCEPT;
  };
  walker = document.createTreeWalker(page, NodeFilter.SHOW_ELEMENT, {
    acceptNode: acceptNode
  }, false);
  _results = [];
  while (child = walker.nextNode()) {
    _results.push(callback(child));
  }
  return _results;
};

getNodeAddress = function(node) {
  var _ref;
  return (node != null ? (_ref = node.dataset) != null ? _ref.address : void 0 : void 0) || (node != null ? node.address : void 0);
};

descendants = function(node) {
  var child, results, _i, _len, _ref;
  results = [];
  _ref = node.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.hasChildNodes()) {
      Array.prototype.push.apply(results, descendants(child));
    }
    results.push(child);
  }
  return results;
};

whenAppears = function(address, cb) {
  var node, _ref;
  if (node = retrieveNodeFromAddress(address)) {
    return cb(node);
  } else {
    if ((_ref = appearanceCallbacks[address]) == null) {
      appearanceCallbacks[address] = [];
    }
    return appearanceCallbacks[address].push(cb);
  }
};

appeared = function(node) {
  var address, cb, _i, _len, _ref, _results;
  address = getNodeAddress(node);
  _ref = appearanceCallbacks[address] || [];
  _results = [];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    cb = _ref[_i];
    _results.push(cb(node));
  }
  return _results;
};

existsNode = function(address) {
  return retrieveNodeFromAddress(address) != null;
};

addNode = function(serializedNode, parentAddress, referenceAddress) {
  var node;
  node = deserializeCompact(serializedNode);
  return whenAppears(parentAddress, function() {
    var parent;
    parent = retrieveNodeFromAddress(parentAddress);
    if (referenceAddress) {
      whenAppears(referenceAddress, function() {
        var reference;
        reference = retrieveNodeFromAddress(referenceAddress);
        return parent.insertBefore(node, reference);
      });
    } else {
      console.log("appending child");
      parent.appendChild(node);
    }
    return appeared(node);
  });
};

retrieveNodeFromAddress = function(address, doc) {
  var descendant, possibleElement, _i, _len, _ref;
  if (doc == null) {
    doc = document;
  }
  console.log('addressbook', address, addressBook);
  if (addressBook[address] != null) {
    return addressBook[address];
  }
  if (getNodeAddress(doc) === address) {
    return doc;
  }
  possibleElement = doc.querySelector("[data-address='" + address + "']");
  if (possibleElement) {
    return possibleElement;
  }
  _ref = descendants(doc);
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    descendant = _ref[_i];
    if (getNodeAddress(descendant) === address) {
      return descendant;
    }
  }
  return console.log('failed to retrieve', address);
};

removeNode = function(address) {
  var node;
  node = retrieveNodeFromAddress(address);
  console.log('removing', node);
  return node.parentNode.removeChild(node);
};

changeNode = function(address, attrName, attrValue) {
  var node;
  node = retrieveNodeFromAddress(address);
  return node.setAttribute(attrName, attrValue);
};

changeNodeProperty = function(address, propName, propValue) {
  var node;
  node = retrieveNodeFromAddress(address);
  return node[propName] = propValue;
};

metaWithProperty = function(prop) {
  return document.querySelector("meta[property='" + prop + "']");
};

setUrl = function(url) {
  return socket.emit('set-url', url);
};

back = function() {
  return socket.emit('back');
};

forward = function() {
  return socket.emit('forward');
};

getRange = function() {
  var range, sel;
  try {
    sel = window.getSelection();
    range = sel.getRangeAt();
  } catch (e) {
    return;
  }
  return range;
};

keysEqual = function(obj, kvs) {
  var k, v;
  for (k in kvs) {
    v = kvs[k];
    if (obj[k] !== v) {
      return false;
    }
  }
  return true;
};

isContentEditable = function(node) {
  var parent, _ref;
  while (parent = node.parentNode) {
    if ((_ref = node.contentEditable) === ('' || 'true')) {
      return true;
    }
    if (node.contentEditable === 'false') {
      return false;
    }
    node = parent;
  }
  return false;
};

isEditingText = function() {
  var commonAncestorContainer, range;
  range = getRange();
  if (!range) {
    return false;
  }
  commonAncestorContainer = range.commonAncestorContainer;
  if (isContentEditable(commonAncestorContainer)) {
    return true;
  }
  if (keysEqual(commonAncestorContainer, {
    nodeName: 'INPUT',
    type: 'text'
  })) {
    return true;
  }
  if (commonAncestorContainer.nodeName === 'TEXTAREA') {
    return true;
  }
  return false;
};

installEventListeners = function(node) {
  if (node.nodeName === 'INPUT' && node.type.toLowerCase() === 'submit' && node.value === '') {
    node.value = "Submit";
  } else if (node.nodeName === 'INPUT' && node.type.toLowerCase() === 'reset' && node.value === '') {
    node.value = "Reset";
  }
  return node.addEventListener('mouseenter', function() {
    return console.log("MOUSE ENTER!");
  });
};

socket.on('node-added', function(serializedNode, parentAddress, referenceAddress) {
  console.log('node-added', serializedNode, parentAddress, referenceAddress);
  if (loadedInitialStuff) {
    console.log('loadedInitialStuff');
    return addNode(serializedNode, parentAddress, referenceAddress);
  } else {
    console.log('not loadedInitialStuff');
    return addToQueue('node-added', serializedNode, parentAddress, referenceAddress);
  }
});

socket.on('node-removed', function(address) {
  console.log('node-removed', address);
  if (loadedInitialStuff) {
    return removeNode(address);
  } else {
    return addToQueue('node-removed', address);
  }
});

socket.on('node-attr-modified', function(address, attrName, attrValue) {
  if (loadedInitialStuff) {
    changeNode(address, attrName, attrValue);
  } else {
    addToQueue('node-attr-modified', address, attrName, attrValue);
  }
  return console.log('node-attr-modified', address, attrName, attrValue);
});

socket.on('node-prop-changed', function(address, propName, propValue) {
  if (loadedInitialStuff) {
    changeNodeProperty(address, propName, propValue);
  } else {
    addToQueue('node-prop-changed', address, propName, propValue);
  }
  return console.log('node-prop-changed', address, propName, propValue);
});

socket.on('input-changed', function(address, newValue, changeId) {
  console.log('input-changed', address, newValue, changeId);
  if (changesCommitted[changeId]) {
    return;
  }
  if (loadedInitialStuff) {
    return changeNodeProperty(address, "value", newValue);
  } else {
    return addToQueue('input-changed', address, "value", newValue);
  }
});

socket.on('text-changed', function(address, text) {
  var textNode;
  textNode = retrieveNodeFromAddress(addres);
  if (textNode.nodeType !== 3) {
    throw "Tried to change text on non-text node";
  }
});

socket.on('reset', function(_arg) {
  var html, k, node, serializedBodyList, serializedHTMLAttributes, serializedHeadList, serializedNode, v, _i, _j, _len, _len1;
  serializedBodyList = _arg.serializedBodyList, serializedHeadList = _arg.serializedHeadList, serializedHTMLAttributes = _arg.serializedHTMLAttributes;
  console.log('reset');
  document.head.innerHTML = '';
  document.body.innerHTML = '';
  html = document.querySelector("html");
  for (k in serializedHTMLAttributes) {
    v = serializedHTMLAttributes[k];
    html.setAttribute(k, v);
  }
  for (_i = 0, _len = serializedHeadList.length; _i < _len; _i++) {
    serializedNode = serializedHeadList[_i];
    node = deserialize(serializedNode);
    document.head.appendChild(node);
  }
  for (_j = 0, _len1 = serializedBodyList.length; _j < _len1; _j++) {
    serializedNode = serializedBodyList[_j];
    node = deserialize(serializedNode);
    document.body.appendChild(node);
  }
  return textNode.data = text;
});

socket.on('canvas-command', function() {
  var address, args, canvasElement, command, context;
  address = arguments[0], command = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
  canvasElement = retrieveNodeFromAddress(address);
  if (canvasElement.nodeName !== "CANVAS") {
    throw "Tried to execute canvas command on non-canvas element";
  }
  context = canvasElement.getContext('2d');
  return context[command].apply(context, args);
});

lastUrl = null;

lastLocationId = null;

socket.on('url-changed', function(url, location_id) {
  lastUrl = url;
  return lastLocationId = location_id;
});

uploadFiles = function(fileList, cb) {
  var file, formData, index, xhr, _i, _len;
  xhr = new XMLHttpRequest;
  formData = new FormData;
  xhr.open('post', '/upload', true);
  xhr.upload.addEventListener('progress', function(e) {});
  xhr.onreadystatechange = function() {
    if (xhr.readyState === 4 && xhr.status === 200) {
      return typeof cb === "function" ? cb() : void 0;
    }
  };
  for (index = _i = 0, _len = fileList.length; _i < _len; index = ++_i) {
    file = fileList[index];
    formData.append(index, file);
  }
  return xhr.send(formData);
};

socket.on('receive-files', function(formAddress) {
  var el;
  return el = retrieveNodeFromAddress(formAddress);
});

wrapInSpanRange = function(textNode, start, end) {
  var afterText, beforeText, beforeTextNode, data, rangeText, spanWrapper, _ref;
  data = textNode.data;
  if (start == null) {
    start = 0;
  }
  if (end == null) {
    end = data.length;
  }
  if (start === 0 && end === data.length && isOnlyChild(textNode)) {
    console.log('doing this');
    return textNode.parentNode;
  }
  beforeText = data.substring(0, start);
  rangeText = data.substring(start, end);
  afterText = data.substring(end);
  spanWrapper = document.createElement('span');
  spanWrapper.innerText = rangeText;
  textNode.parentNode.insertBefore(spanWrapper, textNode);
  if (beforeText !== '') {
    beforeTextNode = document.createTextNode(data.substring(0, start));
    textNode.parentNode.insertBefore(beforeTextNode, spanWrapper);
  }
  if (afterText === '') {
    if ((_ref = textNode.parentNode) != null) {
      _ref.removeChild(textNode);
    }
  } else {
    textNode.data = afterText;
  }
  return spanWrapper;
};

markWhole = function(el, color) {};

eventMessage = function(evt) {
  return socket.emit('event', evt);
};

copyKeys = function(src, dest, keys) {
  var k, _i, _len, _results;
  _results = [];
  for (_i = 0, _len = keys.length; _i < _len; _i++) {
    k = keys[_i];
    _results.push(dest[k] = src[k]);
  }
  return _results;
};

serializeEvent = function(event) {
  var proto, serialized;
  proto = event.__proto__;
  serialized = {};
  copyKeys(event, serialized, ['cancelable', 'bubbles', 'type', 'innerHeight', 'innerWidth']);
  if (event.target === window) {
    serialized.target = 'window';
  } else {
    serialized.target = getNodeAddress(event.target);
  }
  if (event instanceof MouseEvent) {
    copyKeys(event, serialized, ['screenX', 'screenY', 'clientX', 'clientY', 'ctrlKey', 'shiftKey', 'altKey', 'metaKey', 'button', 'detail']);
    serialized.eventClass = 'MouseEvents';
  } else if (event instanceof KeyboardEvent) {
    copyKeys(event, serialized, ['keyIdentifier', 'keyLocation', 'keyCode', 'ctrlKey', 'shiftKey', 'altKey', 'metaKey', 'altGraphKey']);
    serialized.eventClass = "KeyboardEvents";
  } else if (event instanceof MutationEvent) {
    copyKeys(event, serialized, ['prevValue', 'newValue', 'attrName', 'attrChange']);
    serialized.eventClass = 'MutationEvents';
  } else if (event instanceof UIEvent) {
    copyKeys(event, serialized, ['detail']);
    serialized.eventClass = 'UIEvents';
  }
  return serialized;
};

inputChanged = function(target, newValue, changeId) {
  return socket.emit('input-event', target, newValue, changeId);
};

isFileInput = function(node) {
  return node.nodeName === 'INPUT' && node.type === 'file';
};

hasUndesirableClickBehavior = function(node) {
  if (node.nodeType === 1) {
    switch (node.nodeName) {
      case "INPUT":
        if (node.getAttribute('type') === 'submit') {
          return true;
        }
        break;
      case "A":
        console.log("true");
        return true;
    }
  }
  return false;
};

inputChange = function(node) {
  var changeId, newValue;
  newValue = node.value;
  changeId = guid();
  changesCommitted[changeId] = true;
  return inputChange(node.address, newValue, changeId);
};

serializeRange = function(_arg) {
  var commonAncestorContainer, commonAncestorContainerAddress, endContainer, endContainerAddress, endOffset, startContainer, startContainerAddress, startOffset;
  startContainer = _arg.startContainer, endContainer = _arg.endContainer, commonAncestorContainer = _arg.commonAncestorContainer, startOffset = _arg.startOffset, endOffset = _arg.endOffset;
  startContainerAddress = getNodeAddress(startContainer);
  endContainerAddress = getNodeAddress(endContainer);
  commonAncestorContainerAddress = getNodeAddress(commonAncestorContainer);
  return {
    startOffset: startOffset,
    startContainerAddress: startContainerAddress,
    endOffset: endOffset,
    endContainerAddress: endContainerAddress,
    commonAncestorContainerAddress: commonAncestorContainerAddress
  };
};

selectRange = function(serializedRange, color) {};

captureEvents = function(node, eventTypes, handler) {
  var type, _i, _len, _results;
  _results = [];
  for (_i = 0, _len = eventTypes.length; _i < _len; _i++) {
    type = eventTypes[_i];
    _results.push(node.addEventListener(type, handler, true));
  }
  return _results;
};

KeyMap = {
  ENTER: 13,
  SHIFT: 91,
  TAB: 9,
  BACKSPACE: 8,
  LEFT: 37,
  RIGHT: 39,
  UP: 38,
  DOWN: 40
};

submitForm = function(form) {
  return socket.emit('submit-form', form.address);
};

window.onload = function() {
  window.addEventListener('keydown', function(evt) {
    if (evt.keyCode === KeyMap.BACKSPACE) {
      return socket.emit('back', tabSelected);
    }
  });
  if (serializedDocument) {
    loadDocument(currentDocumentID, serializedDocument);
  }
  socket.on('connect', function() {
    console.log("CONNECTED");
    return socket.emit('subscribe', tabId, userId);
  });
  captureEvents(window, ['click', 'dblclick', 'mouseover', 'mousedown', 'mousemove', 'focus', 'blur', 'focusin', 'focusout', 'mousenter', 'mouseleave', 'mouseout', 'mouseup', 'resize', 'scroll', 'keydown', 'keypress', 'keyup'], function(evt) {
    var form;
    switch (evt.type) {
      case 'keypress':
        if (evt.target.nodeName === 'INPUT' && evt.keyCode === 13) {
          event.preventDefault();
          if (form = evt.target.form) {
            submitForm(form);
          }
        }
        break;
      case 'click':
        evt.preventDefault();
        break;
      case 'resize':
        evt.innerHeight = window.innerHeight;
        evt.innerWidth = window.innerWidth;
        break;
      case 'scroll':
        console.log('test', currentDocumentID, document.body.scrollTop);
        scrollMemory[currentDocumentID] = {
          scrollTop: document.body.scrollTop,
          scrollLeft: document.body.scrollLeft
        };
    }
    return eventMessage(serializeEvent(evt));
  });
  window.addEventListener('change', function(evt) {
    var changeId, newValue;
    console.log('input', evt);
    newValue = evt.target.value;
    changeId = guid();
    changesCommitted[changeId] = true;
    return inputChanged(evt.target.address, newValue, changeId);
  });
  window.addEventListener('input', function(evt) {
    var changeId, newValue;
    console.log('input', evt);
    newValue = evt.target.value;
    changeId = guid();
    changesCommitted[changeId] = true;
    return inputChanged(evt.target.address, newValue, changeId);
  });
  return window.addEventListener('selectionchange', function() {});
};
